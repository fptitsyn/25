def is_prime(n):
    if n == 1:  # 1 - ни простое, ни составное число
        return False
    for i in range(2, int(n ** 0.5) + 1):
        if n % i == 0:  # если у n есть любой делитель в промежутке от [2; sqrt(n)], то оно не может быть простым
            return False
    return True  # если мы дошли до сюда, то поздравляю - число простое

# 10) Напишите программу, которая ищет среди целых чисел, принадлежащих числовому отрезку [338472; 338494],
# числа, имеющие ровно 4 различных делителя.
#  Выведите эти четыре делителя для каждого найденного числа в порядке возрастания.

# for i in range(338472, 338494 + 1):
#     a = set()  # используем сет, чтобы исключить повторяющиеся делители
#     for j in range(1, int(i ** 0.5) + 1):  # начинаем перебор с единицы, т. к. про нетривиальные делители ничего не сказано
#         if i % j == 0:
#             a.add(j)
#             a.add(i // j)  # если число является делителем числа, то и число, являющееся результатом этого действия,
#         if len(a) > 4:     # также будет делителем этого числа
#             break
#     if len(a) == 4:
#         print(sorted(a))

# 31)	Напишите программу, которая ищет среди целых чисел, принадлежащих числовому отрезку [1820348; 2880927],
# числа, имеющие ровно 5 различных делителей.
# Выведите эти делители для каждого найденного числа в порядке возрастания.

# итак, согласно основной теореме арифметике, а точнее выводу из неё, любое число, у которого нечётное кол-во делителей,
# можно представить в виде: p^(n-1), где p - простое число, n - количество делителей (нечётное).
# for i in range(1820348, 2880927 + 1):
#     p = i ** (1 / 4)  # n == 5, значит наше i должно быть в виде p^4, p - простое. Идём от обратного:
#     if int(p) == p and is_prime(p):  # если p - полный корень и простое число
#         print(1, p, p ** 2, p ** 3, i)  # такое i нам подходит

# 35)	(Б.С. Михлин) Напишите программу, которая ищет среди целых чисел, принадлежащих числовому отрезку [394480; 394540],
# числа, имеющие максимальное количество различных делителей.
# Выведите информацию о таких числах, расположив их в порядке возрастания.
# Для каждого числа выведите его порядковый номер, количество делителей и два наибольших делителя в порядке убывания.

# mx = 0  # макс. число делителей
# c = 0  # счётчик порядкового номера
# for i in range(394480, 394540 + 1):
#     a = set()
#     for j in range(1, int(i ** 0.5) + 1):
#         if i % j == 0:
#             a.add(j)
#             a.add(i // j)
#     l = len(a)
#     if l > mx:  # если длина сета(кол-во делителей) больше нынешней максимальной длины, то переприсваеваем макс кол-во делителей
#         mx = l  # (это делается не обычным методом, через функцию max(), потому что нам нужно ещё сбрасывать счётчик порядкового номера для каждой новой максимальной длины
#         c = 0
#     if l == mx:  # если кол-во делителей максимально, прибавляем счётчик и выводим согласно условию задачи
#         c += 1
#         print(c, l, sorted(a, reverse=True)[0:2])

# 60)(А.Н. Носкин) Напишите программу, которая ищет среди целых чисел, принадлежащих числовому отрезку [3532000; 3532160],
# простые числа. Выведите все найденные простые числа в порядке убывания,
# слева от каждого числа выведите его номер по порядку.

# c = 0
# for i in range(3532160 + 1, 3532000, -1):
#     if is_prime(i):  # всё вроде норм
#         c += 1
#         print(c, i)

# № 2594 (Уровень: Гроб)
# Найдите все натуральные числа, принадлежащие отрезку [113 000 000; 114 000 000],
# у которых ровно три различных чётных делителя.
# В ответе перечислите найденные числа в порядке возрастания,
# справа от каждого числа запишите его второй по величине чётный делитель.

# for i in range(113_000_000, 114_000_000 + 1):
#     p = (i / 2) ** 0.5  # если у числа нечётное количество чётных делителей, его можно представить в виде
#     if int(p) == p and is_prime(p):  # n = 2 * p^(n-1), где p - простое число, n - количество делителей(нечётное)
#         print(i, int(2 * p))         # у нас n = 3

# № 2592 (Уровень: Гроб)
# Найдите все натуральные числа, принадлежащие отрезку [55 000 000; 60 000 000],
# у которых ровно пять различных нечётных делителей (количество чётных делителей может быть любым).
# В ответе перечислите найденные числа, справа от каждого числа запишите его наибольший нечётный делитель.

# for i in range(55_000_000, 60_000_000 + 1):
#     n = i
#     while n % 2 == 0:  # т.к. нам нужны только нечётные делители, то нам нужно избавиться от всех чётных делителей,
#         n //= 2        # путём деления на 2, пока делится
#     p = n ** (1 / 4)  # дальше по отработанной схеме (n = 5)
#     if int(p) == p and is_prime(p):
#         print(i, int(p ** 4))

# № 7273 OpenFIPI (Уровень: Базовый)
# Назовём маской числа последовательность цифр, в которой также могут встречаться следующие символы:
# – символ «?» означает ровно одну произвольную цифру;
# – символ «*» означает любую последовательность цифр произвольной длины; в том числе «*» может задавать и пустую последовательность.
# Например, маске 123*4?5 соответствуют числа 123405 и 12300405.
# Среди натуральных чисел, не превышающих 10^9, найдите все числа, соответствующие маске 12345?7?8, делящиеся на число 23 без остатка.
# В ответе запишите в первом столбце таблицы все найденные числа в порядке возрастания, а во втором столбце – соответствующие им результаты деления этих чисел на 23.
# Количество строк в таблице для ответа избыточно.

# from fnmatch import *  # легенда
# k = 23  # делитель
# for i in range(k, 10**9, k):  # берём делитель как шаг, так как очевидно, что такие числа будут делиться на наше число
#     if fnmatch(str(i), "12345?7?8"):  # легенда (просто берём наше число в виде строки как первый параметр и саму маску как второй параметр)
#         print(i, i // k)

# № 5227 (Уровень: Сложный)
# (М. Ишимов) Назовём маской числа последовательность цифр, в которой также могут встречаться следующие символы:
# - символ «?» означает ровно одну произвольную цифру;
# - символ «*» означает любую последовательность цифр произвольной длины; в том числе «*» может задавать и пустую последовательность.
# Например, маске 123*4?5 соответствуют числа 123405 и 12300405.
# Среди натуральных чисел, не превышающих 10^7, найдите все числа, соответствующие маске 3*52?,
# у которых нечётное количество делителей.
# В ответе запишите в первом столбце таблицы все найденные числа в порядке возрастания, а во втором столбце – соответствующие им максимальные делители, не считая самого числа.

# from fnmatch import *
# for i in range(3000, 10**7):  # в данном случае можем начать с 3000, так как при нашей маске это числе не будет меньше 3520
#     if fnmatch(str(i), "3*52?"):
#         for n in range(2, 20, 2):  # перебираем только чётные степени, т. к. нам нужно числе в виде p^(n-1), где n - нечётное
#             p = i ** (1 / n)
#             if int(p) == p and is_prime(p):
#                 print(i, int(p ** (n - 1)))
#                 break
#             else:  # почему-то всё пошло не по плану, и наша формула не сработала :(
#                 a = set()  # в таком случае прибегнем к стандратному методу нахождения делителей, т. к. этот метод мы используем не для всех чисел,
#                 for j in range(1, int(i ** 0.5) + 1): # программа выполняется всё ещё довольно быстро (5 секунд на моём компьютере)
#                     if i % j == 0:
#                         a.add(j)
#                         a.add(i // j)
#                 if len(a) % 2 != 0:
#                     print(i, sorted(a)[-2])
#                     break

# № 5224 (Уровень: Сложный)
# (М. Ишимов) Назовём маской числа последовательность цифр, в которой также могут встречаться следующие символы:
# — символ «?» означает ровно одну произвольную цифру.
# — символ «*» означает любую последовательность цифр произвольной длины; в том числе «*» может задавать и пустую последовательность.
# Например, маске 123*4?5 соответствуют числа 123405 и 12300405.
# Найдите все натуральные числа, квадраты которых не превышают 10^10 и соответствуют маске 4*1?009.
# В ответе запишите в первом столбце таблицы все найденные числа в порядке возрастания, а во втором столбце – соответствующие им квадраты.

from fnmatch import *  # легенда
for i in range(10**5):  # i^2 <= 10^10 -> i <= 10^5
    if fnmatch(str(i * i), "4*1?009"):  # всё как обычно
        print(i, i * i)
